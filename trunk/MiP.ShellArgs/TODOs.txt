Once only parsing of single options
{
    normally, this is allowed even if not a collection
        -set value1 -set value2 -set value3
    make a [OnceOnlyAttribute] and .OnceOnly() method to make the option really accept only one value.

    make this the default behaviour, name the method "AllowReuse" and negate the functionality
}

Allow collections to be cleared when parsing a collection option multiple times
{
   /add 1 2 3 /add 4 5 6
   should yield only {4, 5, 6} when the ClearWhenReused() method is used
   this is only relevant in AutoWiring

   make this the default behaviour, name the method "NoClearOnReuse" and negate the functionality
}

### Release ###

{
    OverrideExistingOptions() 
        which allows to override options instead of throwing an error on duplicate option names
    ContinuePositions() 
        which appends positional options to options which have been created with a previous call to AutoWire()
    
    if possible, both methods should be callable before and after calls to  WithOption
    document both in Autowiring.wiki
}

Add support for converting with TypeDescriptor.

Support for Dictionary <string, AnyType>
{
    A property of Type IDictionary <string, int> will create options for dynamic properties:
    /p:X=1 /p:Y=2 -> set X=1, Y=2
    This has to have full support for the string conversion
}

Define individual options to be case sensitive
{
    uniqueness changes:	case insensitive options must not have a sensitive match
}

Possibility to forbid positional options as named options
{
    .AtPosition(1).DisableAsNamed()
}

### Release ###

Dynamically make an option required based on a condition (conditional options)
{
    Fluent: 
        .RequiredWhen(()=>true)
        .RequiredWhen<User>(u=>u.Short == "System")
}

Dynamically add options on an event (when parsed)
{
        .WhenParsed("add", pc => { 
                if (pc.Value == "User") pc.Parser.AutoWire<User>();  
            })
}

### Release ###

Collect Errors into ParseResult
{
    .CollectErrors()

    collection exceptions and errors into the parse result
    show the user all errors at once instead of making him fix one after the other
}

### Release ###

Help
{
    better handling of 
    - no arguments -> make an attribute how no parameters behave
    - help
    - hidden options which are not shown in help.

    detail help per argument
    - aliases, values, options, formatting options
    - path [list of] value
      Sets the value... some descriptive description
      [Allowed values: enum, bool, +/-]
      [Default: xyz]
      This parameter is optional|required
}

internal options: 
{
    /Args.Debug+ debugging of argument parsing
    /Args.Pattern="yyyy-MM-dd"
    /Args.Culture="de-AT"    /Args.Culture="invariant"
    /Args.Save="Filename" -> serialize args after parsing to file (Json?)
    /Args.Load="Filename" -> deserialize args before parsing from file (Json?)

    These must not influence positional options when they occure at beginning.
    Example when "one" and "two" are used as positional, this must still work:

    xxx.exe /Args.Debug+ one two

    This turns on debugging but still uses "one" and "two" as positional options
}
