Documentation:
# Settings
# Fluent Api
# Result
# Help

{
    OverrideExistingOptions() 
        which allows to override options instead of throwing an error on duplicate option names
    ContinuePositions() 
        which appends positional options to options which have been created with a previous call to AutoWire()
    
    if possible, both methods should be callable before and after calls to  WithOption
    document both in Autowiring.wiki
}

Add support for converting with TypeDescriptor.

Support for Dictionary <string, AnyType>
{
    A property of Type IDictionary <string, int> will create options for dynamic properties:
    /p:X=1 /p:Y=2 -> set X=1, Y=2
    This has to have full support for the string conversion
}

Strict Parsing of single options
{
    normally, this is allowed even if not a collection
        -set value1 -set value2 -set value3
    make a [StrictAttribute] and .Strict() method to make the option really accept only one value.
}

Help
{	
    better handling of 
    - no arguments -> make an attribute how no parameters behave
    - help
    - hidden options which are not shown in help.

    detail help per argument
    - aliases, values, options, formatting options
    - path [list of] value
      Sets the value... some descriptive description
      [Allowed values: enum, bool, +/-]
      [Default: xyz]
      This parameter is optional|required
}

Define individual options to be case sensitive
{
    uniqueness changes:	case insensitive options must not have a sensitive match
}

Possibility to forbid positional options as named options
{
    .AtPosition(1).DisableAsNamed()
}

Dynamically make an option required based on a condition (conditional options)
{
    Fluent: 
        .RequiredWhen(()=>true)
        .RequiredWhen<User>(u=>u.Short == "System")
}

Dynamically add options on an event (when parsed)
{
        .WhenParsed("add", pc => { 
                if (pc.Value == "User") pc.Parser.AutoWire<User>();  
            })
}

Collect Errors into ParseResult
{
    .CollectErrors()

    collection exceptions and errors into the parse result
    show the user all errors at once instead of making him fix one after the other
}

internal options: 
{
    /Args.Debug+ debugging of argument parsing
    /Args.Pattern="yyyy-MM-dd"
    /Args.Culture="de-AT"    /Args.Culture="invariant"
    /Args.Save="Filename" -> serialize args after parsing to file (Json?)
    /Args.Load="Filename" -> deserialize args before parsing from file (Json?)

    These must not influence positional options when they occure at beginning.
    Example when "one" and "two" are used as positional, this must still work:

    xxx.exe /Args.Debug+ one two

    This turns on debugging but still uses "one" and "two" as positional options
}
